package main

import (
	"context"
	"database/sql"
	"embed"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	_ "github.com/sijms/go-ora/v2"
)

//go:embed static/*
var staticFiles embed.FS

type Value struct {
	ID        int       `json:"id"`
	Value     string    `json:"value"`
	CreatedAt time.Time `json:"created_at"`
}

var db *sql.DB

func main() {
	var err error
	db, err = connectDB()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	if err := ensureTable(); err != nil {
		log.Fatalf("Failed to ensure table exists: %v", err)
	}

	http.HandleFunc("/", handleIndex)
	http.HandleFunc("/api/values", handleValues)
	http.HandleFunc("/api/health", handleHealth)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on port %s", port)
	if err := http.ListenAndServe(":"+port, nil); err != nil {
		log.Fatal(err)
	}
}

// parseOracleURL converts a JDBC Oracle URL to a go-ora connection string.
// Input format: jdbc:oracle:thin:@{host}:{port}/{database}
// Output format: oracle://{username}:{password}@{host}:{port}/{database}
func parseOracleURL(oracleURL, username, password string) (string, error) {
	prefix := "jdbc:oracle:thin:@"
	if !strings.HasPrefix(oracleURL, prefix) {
		return "", fmt.Errorf("ORACLE_URL must start with %s, got %q", prefix, oracleURL)
	}

	hostPortDb := strings.TrimPrefix(oracleURL, prefix)

	// Split into host:port and database
	hostPort, database, found := strings.Cut(hostPortDb, "/")
	if !found {
		return "", fmt.Errorf("failed to parse database from ORACLE_URL: %q", oracleURL)
	}

	// Split host and port
	host, port, found := strings.Cut(hostPort, ":")
	if !found {
		return "", fmt.Errorf("failed to parse host:port from ORACLE_URL: %q", oracleURL)
	}

	connURL := &url.URL{
		Scheme: "oracle",
		User:   url.UserPassword(username, password),
		Host:   fmt.Sprintf("%s:%s", host, port),
		Path:   "/" + database,
	}
	return connURL.String(), nil
}

func connectDB() (*sql.DB, error) {
	oracleURL := os.Getenv("ORACLE_URL")
	username := os.Getenv("ORACLE_USERNAME")
	password := os.Getenv("ORACLE_PASSWORD")

	if oracleURL == "" || username == "" || password == "" {
		return nil, fmt.Errorf("ORACLE_URL, ORACLE_USERNAME and ORACLE_PASSWORD must be set")
	}

	connStr, err := parseOracleURL(oracleURL, username, password)
	if err != nil {
		return nil, err
	}

	db, err := sql.Open("oracle", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to open connection: %w", err)
	}

	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	log.Println("Successfully connected to Oracle database")
	return db, nil
}

func ensureTable() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Check if table exists
	var count int
	err := db.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM user_tables WHERE table_name = 'NAIS_TEST_VALUES'
	`).Scan(&count)
	if err != nil {
		return fmt.Errorf("failed to check if table exists: %w", err)
	}

	if count == 0 {
		_, err = db.ExecContext(ctx, `
			CREATE TABLE nais_test_values (
				id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				value VARCHAR2(255) NOT NULL,
				created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
			)
		`)
		if err != nil {
			return fmt.Errorf("failed to create table: %w", err)
		}
		log.Println("Created table nais_test_values")
	}

	return nil
}

func handleIndex(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	content, err := staticFiles.ReadFile("static/index.html")
	if err != nil {
		http.Error(w, "Failed to read index.html", http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.Write(content)
}

func handleValues(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		getValues(w, r)
	case http.MethodPost:
		addValue(w, r)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func getValues(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	rows, err := db.QueryContext(ctx, `
		SELECT id, value, created_at FROM nais_test_values ORDER BY created_at DESC
	`)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to query values: %v", err), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var values []Value
	for rows.Next() {
		var v Value
		if err := rows.Scan(&v.ID, &v.Value, &v.CreatedAt); err != nil {
			http.Error(w, fmt.Sprintf("Failed to scan row: %v", err), http.StatusInternalServerError)
			return
		}
		values = append(values, v)
	}

	if values == nil {
		values = []Value{}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(values)
}

func addValue(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Value string `json:"value"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if req.Value == "" {
		http.Error(w, "Value cannot be empty", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	_, err := db.ExecContext(ctx, `INSERT INTO nais_test_values (value) VALUES (:1)`, req.Value)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to insert value: %v", err), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		http.Error(w, fmt.Sprintf("Database unhealthy: %v", err), http.StatusServiceUnavailable)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
}
